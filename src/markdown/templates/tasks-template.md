# 任务文档 - [功能名称]

> **关于任务拆分**：
>
> 本模板提供的是**基础任务框架**，实际使用时需要根据功能复杂度灵活调整：
> - **小功能**：按模板的 6 个核心任务执行即可
> - **大功能**：可以将任何一个任务拆分成多个子任务
> - **复杂功能**：建议先拆分成多个独立的功能点，每个功能点用一个任务文档
>
> **前端开发建议**：
> - 如果功能包含 UI 界面，推荐采用 **UI First** 策略
> - 如果是工具库、SDK、Hooks 等无 UI 功能，按常规顺序执行核心任务

---

## 核心任务清单

- [ ] 1. 定义类型接口
  - **文件**：`src/types/[feature].ts`
  - **内容**：定义功能相关的 TypeScript 接口、类型别名、枚举
  - **目的**：为功能实现建立类型安全基础
  - **_复用**：`src/types/base.ts` 或项目现有基础类型
  - **_需求**：需求文档对应章节
  - **_提示**：角色：TypeScript 开发者，专注于类型系统和接口设计 | 任务：根据需求文档定义完整的类型接口，扩展现有基础类型 | 限制：不修改现有基础接口，保持向后兼容性，遵循项目命名约定 | 成功标准：所有接口编译无错误，类型覆盖完整，正确继承基础类型

- [ ] 2. 实现核心功能模块
  - **文件**：根据功能性质确定文件路径和结构
  - **内容**：实现功能的核心逻辑和主要功能
  - **目的**：完成功能的主要实现
  - **_复用**：项目现有工具函数、基础类、Hooks 等
  - **_需求**：需求文档对应章节
  - **_提示**：角色：前端开发者，擅长 JavaScript/TypeScript 和项目技术栈 | 任务：实现核心功能逻辑，遵循项目现有架构模式 | 限制：遵循项目代码规范，不重复造轮子，保持代码可测试性 | 成功标准：功能逻辑正确实现，代码可读性好，符合项目架构

  > **提示**：如果核心功能较复杂，可以拆分为多个子任务：
  > - [ ] 2.1 实现基础功能逻辑
  > - [ ] 2.2 添加高级功能
  > - [ ] 2.3 处理数据转换
  > 每个子任务都应该有自己的文件、内容、目的、_复用、_需求、_提示字段

- [ ] 3. 添加辅助功能和工具方法
  - **文件**：根据功能需要确定
  - **内容**：实现辅助函数、工具方法、配置等
  - **目的**：完善功能的辅助能力
  - **_复用**：项目现有工具库
  - **_需求**：需求文档对应章节
  - **_提示**：角色：前端开发者 | 任务：实现辅助功能，确保与主功能良好配合 | 限制：保持函数职责单一，避免过度设计 | 成功标准：辅助功能完整，易于使用和维护

- [ ] 4. 完善错误处理和边界情况
  - **修改文件**：相关功能模块
  - **内容**：添加错误处理、参数校验、边界情况处理
  - **目的**：提升代码健壮性
  - **_复用**：项目错误处理工具
  - **_需求**：需求文档 - 异常处理章节
  - **_提示**：角色：前端开发者 | 任务：处理各种异常情况，提供清晰的错误信息 | 限制：不吞掉错误，确保错误可追踪 | 成功标准：异常情况有友好提示，边界条件处理正确

- [ ] 5. 浏览器测试和验证
  - **内容**：在浏览器中手动测试功能，覆盖正常流程和异常场景
  - **目的**：确保功能在真实环境中正常工作
  - **_复用**：开发环境配置
  - **_需求**：所有需求
  - **_提示**：角色：前端开发者 | 任务：在浏览器中测试所有功能点，包括正常操作、边界情况、错误场景 | 限制：测试要覆盖不同浏览器（如需要），确保响应式正常 | 成功标准：所有功能在浏览器中按预期工作，无明显 bug

- [ ] 6. 集成和验收
  - **内容**：集成到项目中，进行端到端验证
  - **目的**：确保功能在实际环境中正常工作
  - **_复用**：项目集成工具和测试环境
  - **_需求**：所有需求
  - **_提示**：角色：集成工程师 | 任务：完成功能集成，进行最终验收 | 限制：确保不破坏现有功能 | 成功标准：功能完整集成，端到端流程正常，通过验收标准

---

## 如果功能包含 UI 界面，补充以下任务：

- [ ] UI.1 准备 Mock 数据（UI 开发前）
  - **文件**：`src/mocks/[feature]Data.ts`
  - **内容**：创建模拟数据用于 UI 开发，覆盖各种场景
  - **目的**：让 UI 组件先用假数据渲染，不依赖后端
  - **_复用**：项目 Mock 工具库
  - **_需求**：需求文档 - 数据处理章节
  - **_提示**：角色：前端开发者 | 任务：根据类型定义创建丰富的 Mock 数据 | 限制：Mock 数据必须符合类型定义，覆盖边界情况 | 成功标准：Mock 数据支撑 UI 各种展示场景

- [ ] UI.2 获取设计稿信息
  - **操作**：使用 MasterGo MCP 服务读取设计稿（如可用）
  - **内容**：提取页面布局、组件层级、样式规范、交互状态
  - **目的**：了解 UI 设计的完整信息，指导组件开发
  - **_复用**：设计文档 - UI 设计稿链接
  - **_需求**：需求文档 - 视觉呈现章节
  - **_提示**：角色：前端开发者 | 任务：通过 MasterGo MCP 或手动查看设计稿，记录关键信息 | 限制：确保覆盖所有页面和状态 | 成功标准：明确每个组件的设计要求

- [ ] UI.3 实现 UI 组件
  - **文件**：`src/components/[ComponentName]/index.tsx`
  - **内容**：实现 UI 组件，先用 Mock 数据测试
  - **目的**：实现可复用的 UI 单元
  - **_复用**：项目 UI 组件库
  - **_需求**：需求文档 - 视觉呈现章节
  - **_提示**：角色：React 开发者 | 任务：创建组件，Props 接口清晰，参考设计稿实现 | 限制：不在组件内调用 API，保持组件纯粹 | 成功标准：使用 Mock 数据渲染正确，组件可复用

  > **提示**：如果 UI 较复杂，应拆分为多个子任务：
  > - [ ] UI.3.1 实现基础展示组件
  > - [ ] UI.3.2 实现组件样式
  > - [ ] UI.3.3 创建容器组件
  > - [ ] UI.3.4 实现交互组件（如表单、弹窗）

- [ ] UI.4 页面组装（静态版本）
  - **文件**：`src/pages/[PageName]/index.tsx`
  - **内容**：组合组件，使用 Mock 数据，添加基本交互
  - **目的**：实现完整的页面布局
  - **_复用**：已实现的 UI 组件
  - **_需求**：需求文档 - 视觉呈现、交互操作章节
  - **_提示**：角色：React 开发者 | 任务：组合组件，使用 Mock 数据填充 | 限制：暂不调用 API | 成功标准：页面完整可见，基本交互可操作

- [ ] UI.5 连接真实数据和逻辑
  - **修改文件**：UI 组件和页面
  - **内容**：将 Mock 数据替换为真实数据，连接业务逻辑
  - **目的**：让 UI 展示真实数据并执行真实操作
  - **_复用**：任务 2 实现的核心功能模块
  - **_需求**：需求文档 - 数据处理、交互操作章节
  - **_提示**：角色：React 开发者 | 任务：替换 Mock 数据为真实数据源 | 限制：保持组件接口稳定 | 成功标准：页面展示真实数据，操作功能正常

- [ ] UI.6 配置路由（如需要）
  - **文件**：路由配置文件
  - **内容**：配置页面路由，添加到导航
  - **目的**：让页面可通过路由访问
  - **_复用**：项目路由配置方式
  - **_需求**：需求文档 - 交互操作章节
  - **_提示**：角色：前端开发者 | 任务：按项目规范添加路由 | 限制：遵循路由命名规范 | 成功标准：可通过 URL 访问页面

---

## 附录

### 如何处理大型功能？

**方案 1：拆分成多个功能点**（推荐）
- 将大功能拆分成多个独立的小功能
- 每个小功能创建一个独立的任务文档
- 示例：电商系统的"订单管理"可以拆分为：
  - 订单列表功能
  - 订单详情功能
  - 订单创建功能
  - 订单状态流转功能

**方案 2：在任务内部拆分子任务**
- 保持一个任务文档
- 将复杂任务拆分成多个子任务
- 示例：任务 2 拆分为 2.1、2.2、2.3 等
- 适合：功能紧密耦合，不适合完全拆分的情况

**方案 3：混合使用**
- 主功能点用独立任务文档
- 每个主功能点内部再拆分子任务
- 示例：
  - 订单列表（独立文档）→ 任务 2 拆分为列表查询、分页、筛选
  - 订单详情（独立文档）→ 任务 2 拆分为基本信息、商品列表、物流信息

### 任务拆分原则

**何时拆分成多个功能点？**
- ✅ 功能可以独立交付和验收
- ✅ 功能之间耦合度低
- ✅ 可以并行开发
- ✅ 有独立的需求文档章节

**何时拆分成子任务？**
- ✅ 功能内部逻辑复杂
- ✅ 涉及多个文件或模块
- ✅ 需要分步骤实现
- ✅ 但整体是一个功能单元

### 任务执行顺序

**根据功能性质灵活调整：**

**纯逻辑功能**（如 Hooks、工具库、SDK）：
```
任务 1（类型） → 任务 2（核心实现） → 任务 3（辅助功能） →
任务 4（错误处理） → 任务 5（浏览器测试） → 任务 6（集成验收）
```

**纯 UI 功能**（如组件、页面）：
```
任务 1（类型） → UI.1（Mock） → UI.2（设计稿） → UI.3（组件） →
UI.4（页面） → 任务 2（逻辑） → UI.5（连接） →
任务 4（错误处理） → 任务 5（浏览器测试） → 任务 6（集成验收）
```

**混合功能**（如完整特性）：
```
任务 1（类型） → UI.1（Mock） → UI.2（设计稿） →
UI.3（组件） → UI.4（页面） → 任务 2-3（逻辑） →
UI.5（连接） → 任务 4（错误处理） → 任务 5（浏览器测试） → 任务 6（集成验收）
```

### 需求追溯

| 任务编号 | 对应需求文档 | 对应设计文档 |
|---------|-------------|-------------|
| 1 | 数据结构相关章节 | 数据层设计 |
| 2-3 | 功能需求章节 | 核心设计方案 |
| 4 | 异常处理章节 | 错误处理设计 |
| 5 | 所有需求 | 测试验证 |
| 6 | 所有需求 | 集成方案 |
| UI.1-UI.4 | 视觉呈现、交互操作 | 视图层设计 |
| UI.5 | 数据处理、交互操作 | 集成方案 |

### 验收检查清单

**功能完整性**：
- [ ] 所有需求文档中的功能点已实现
- [ ] 功能按预期工作
- [ ] 数据处理正确

**代码质量**：
- [ ] TypeScript 类型完整无错误
- [ ] 代码符合项目规范
- [ ] 无明显性能问题
- [ ] 代码可读性和可维护性好

**用户体验**（如有 UI）：
- [ ] UI 与设计稿一致
- [ ] 交互流畅，反馈及时
- [ ] 加载和错误状态友好
- [ ] 响应式适配良好

**集成验证**：
- [ ] 功能完整集成到项目
- [ ] 不破坏现有功能
- [ ] 端到端流程正常

